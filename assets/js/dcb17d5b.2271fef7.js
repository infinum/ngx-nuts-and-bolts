"use strict";(self.webpackChunkngx_nuts_and_bolts_docs=self.webpackChunkngx_nuts_and_bolts_docs||[]).push([[613],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return c}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),p=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=p(e.components);return i.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(t),c=a,h=u["".concat(s,".").concat(c)]||u[c]||m[c]||o;return t?i.createElement(h,r(r({ref:n},d),{},{components:t})):i.createElement(h,r({ref:n},d))}));function c(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=t[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4754:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return d},default:function(){return u}});var i=t(7462),a=t(3366),o=(t(7294),t(3905)),r=["components"],l={id:"environment-variables",title:"Environment variables",sidebar_label:"Environment variables"},s=void 0,p={unversionedId:"services/environment-variables",id:"services/environment-variables",title:"Environment variables",description:"Most applications that are deployed to multiple environments have a need for environment variables that can have different values, depending on which environment the app is running in. EnvironmentVariablesService and the corresponding modules from ngx-nuts-and-bolts allow for handling of environment variables in a way that does not require application to be re-built nor to be re-deployed (only restarted in the case of SSR). This allows the same build to be deployed to multiple environments, increasing reliability and providing confidence that the codebase that was tested in pre-production environment is identical to what gets deployed to production. Additionally, this approach works well with Docker - the same Docker image containing the build can be run with different environment values for different environments.",source:"@site/docs/services/environment-variables.md",sourceDirName:"services",slug:"/services/environment-variables",permalink:"/ngx-nuts-and-bolts/docs/services/environment-variables",tags:[],version:"current",frontMatter:{id:"environment-variables",title:"Environment variables",sidebar_label:"Environment variables"},sidebar:"mainSidebar",previous:{title:"EnumProperty pipe",permalink:"/ngx-nuts-and-bolts/docs/pipes/enum-property"},next:{title:"Fade and Height animations",permalink:"/ngx-nuts-and-bolts/docs/animations/"}},d=[{value:"1. Features",id:"1-features",children:[{value:"1.1. Main service and module",id:"11-main-service-and-module",children:[],level:3},{value:"1.2. Loaders",id:"12-loaders",children:[{value:"SSR loader",id:"ssr-loader",children:[],level:4},{value:"Static loader",id:"static-loader",children:[],level:4}],level:3},{value:"1.3. Race conditions during application initialization",id:"13-race-conditions-during-application-initialization",children:[],level:3}],level:2},{value:"2. Usage and example applications",id:"2-usage-and-example-applications",children:[{value:"2.1. Configuring static loader",id:"21-configuring-static-loader",children:[{value:"With config",id:"with-config",children:[],level:4},{value:"Without config",id:"without-config",children:[],level:4}],level:3},{value:"2.2. Configuring SSR loader",id:"22-configuring-ssr-loader",children:[],level:3},{value:"2.3. Implementing and providing a custom loader",id:"23-implementing-and-providing-a-custom-loader",children:[],level:3},{value:"2.4. Setting values for development only",id:"24-setting-values-for-development-only",children:[],level:3},{value:"2.5. Example applications",id:"25-example-applications",children:[],level:3}],level:2},{value:"3. Unit testing",id:"3-unit-testing",children:[],level:2},{value:"4. Opinion piece - what about Angular&#39;s <code>environment</code> files?",id:"4-opinion-piece---what-about-angulars-environment-files",children:[],level:2}],m={toc:d};function u(e){var n=e.components,t=(0,a.Z)(e,r);return(0,o.kt)("wrapper",(0,i.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Most applications that are deployed to multiple environments have a need for environment variables that can have different values, depending on which environment the app is running in. ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesService")," and the corresponding modules from ",(0,o.kt)("inlineCode",{parentName:"p"},"ngx-nuts-and-bolts")," allow for handling of environment variables in a way that does not require application to be re-built nor to be re-deployed (only restarted in the case of SSR). This allows the same build to be deployed to multiple environments, increasing reliability and providing confidence that the codebase that was tested in pre-production environment is identical to what gets deployed to production. Additionally, this approach works well with Docker - the same Docker image containing the build can be run with different environment values for different environments."),(0,o.kt)("h2",{id:"1-features"},"1. Features"),(0,o.kt)("p",null,"Environment variables feature set consists of two main parts - ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesService")," and a loader. ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesService")," service is what is used in the application when you need to read some specific environment variable value. A loader is what initializes the ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesService")," with actual values. Depending on project architecture, you might use one of two loaders that are provided with the library. If you seek something more specific, you can implement a custom loader."),(0,o.kt)("h3",{id:"11-main-service-and-module"},"1.1. Main service and module"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesService")," is provided by ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesModule"),". This module also provides an ",(0,o.kt)("inlineCode",{parentName:"p"},"APP_INITIALIZER")," that uses the loader of you choice to initialize the service during application initialization."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"init")," method is intentionally available publicly and can be called multiple times in order not to restrict the users in whatever use cases they might have. If you use a loader, you probably will not have to call it from your application code (not even once), but it is available if you have the need for it."),(0,o.kt)("h3",{id:"12-loaders"},"1.2. Loaders"),(0,o.kt)("p",null,"The two available loaders are ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesSSRLoader")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesStaticLoader"),"."),(0,o.kt)("h4",{id:"ssr-loader"},"SSR loader"),(0,o.kt)("p",null,"As the name suggests, ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesSSRLoader")," is to be used with Angular Universal (Server-Side Rendering) applications. It reads from ",(0,o.kt)("inlineCode",{parentName:"p"},"process.env")," on server-side and transfers the values to the client browser using the ",(0,o.kt)("inlineCode",{parentName:"p"},"TransferState")," service."),(0,o.kt)("p",null,"This is the recommended loader if you use SSR, although you can still use any other loader if there is a specific need."),(0,o.kt)("p",null,"Please note that this loader is part of a separate NPM package (",(0,o.kt)("inlineCode",{parentName:"p"},"@infinumjs/ngx-nuts-and-bolts-ssr"),") because of ",(0,o.kt)("inlineCode",{parentName:"p"},"node")," dependency. This keeps the main NPM package (",(0,o.kt)("inlineCode",{parentName:"p"},"@infinumjs/ngx-nuts-and-bolts"),") free of any node dependencies."),(0,o.kt)("h4",{id:"static-loader"},"Static loader"),(0,o.kt)("p",null,"The main use case for ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesStaticLoader")," is for statically built applications that do not use SSR."),(0,o.kt)("p",null,"Any custom loaders you might need to implement are injectable classes that implement ",(0,o.kt)("inlineCode",{parentName:"p"},"IEnvironmentVariablesLoader"),". Please check out the source code of the two available loaders for some examples."),(0,o.kt)("h3",{id:"13-race-conditions-during-application-initialization"},"1.3. Race conditions during application initialization"),(0,o.kt)("p",null,"Because all the ",(0,o.kt)("inlineCode",{parentName:"p"},"APP_INITIALIZER"),"s start being resolved at the same time, there is no guarantee in which order they will be resolved. This can cause issues if you have an asynchronous environment variables loader and you need to use ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesService")," within some other ",(0,o.kt)("inlineCode",{parentName:"p"},"APP_INITIALIZER"),"s - it could happen that ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesService")," is not initialized in time."),(0,o.kt)("p",null,"As a workaround for such cases, other initializers can await for ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesService"),"'s ",(0,o.kt)("inlineCode",{parentName:"p"},"initDone$")," observable to emit ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesSSRLoader")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesStaticLoader")," loaders that are provided with the library are not affected by this issue, but some custom loaders that are written for specific application needs might be."),(0,o.kt)("h2",{id:"2-usage-and-example-applications"},"2. Usage and example applications"),(0,o.kt)("p",null,"Please follow these steps to set up the environment variables service and loaders:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Define a string enum that defines all the needed environment variables"),(0,o.kt)("p",{parentName:"li"},"Example enum:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export enum EnvironmentVariable {\n    FOO = 'NGX_NUTS_AND_BOLTS_EXAMPLE_FOO',\n    BAR = 'NGX_NUTS_AND_BOLTS_EXAMPLE_BAR',\n}\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Import ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesModule")," into your ",(0,o.kt)("inlineCode",{parentName:"p"},"AppModule"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Import an existing loader module or provide a custom loader (also in ",(0,o.kt)("inlineCode",{parentName:"p"},"AppModule"),")")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Inject ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesService")," and call ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," method wherever you need some environment variable value"))),(0,o.kt)("h3",{id:"21-configuring-static-loader"},"2.1. Configuring static loader"),(0,o.kt)("p",null,"Import ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesStaticLoaderModule")," with or without config."),(0,o.kt)("h4",{id:"with-config"},"With config"),(0,o.kt)("p",null,"This option will use fully static values that are defined when the module is imported. This can be useful for setting environment variables in development of if you are reading them from ",(0,o.kt)("inlineCode",{parentName:"p"},"window.env")," or similar."),(0,o.kt)("p",null,"Some examples:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@NgModule({\n    imports: [\n        EnvironmentVariablesModule,\n        EnvironmentVariablesStaticLoaderModule.withConfig({\n            environmentVariablesRecord: {\n                [EnvironmentVariable.FOO]: 'I am Foo',\n                [EnvironmentVariable.BAR]: 'I am Bar',\n            },\n        }),\n    ],\n})\nexport class AppModule {}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@NgModule({\n    imports: [\n        EnvironmentVariablesModule,\n        EnvironmentVariablesStaticLoaderModule.withConfig({\n            environmentVariablesRecord: window.env,\n        }),\n    ],\n})\nexport class AppModule {}\n")),(0,o.kt)("h4",{id:"without-config"},"Without config"),(0,o.kt)("p",null,"If the module is imported without calling ",(0,o.kt)("inlineCode",{parentName:"p"},"withConfig"),", you need to provide the config manually. An example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@NgModule({\n    imports: [EnvironmentVariablesModule, EnvironmentVariablesStaticLoaderModule],\n    providers: [\n        {\n            provide: ENVIRONMENT_VARIABLES_STATIC_LOADER_CONFIG,\n            useFactory: (window: Window) => {\n                return {\n                    environmentVariablesRecord: window.env,\n                };\n            },\n            deps: [WINDOW],\n        },\n        {\n            provide: WINDOW,\n            useValue: window,\n        },\n    ],\n})\nexport class AppModule {}\n")),(0,o.kt)("p",null,"This example is functionally the same as ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesStaticLoaderModule.withConfig")," example where window.env was used directly (without injection token). Generally, it is a good practice to hide globals behind injection tokens and your app might already have an injection token for ",(0,o.kt)("inlineCode",{parentName:"p"},"Window")," because you are using something else from ",(0,o.kt)("inlineCode",{parentName:"p"},"Window")," as well. The example above shows how to use that injection token when configuring ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesStaticLoader"),"."),(0,o.kt)("h3",{id:"22-configuring-ssr-loader"},"2.2. Configuring SSR loader"),(0,o.kt)("p",null,"Before using ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesSSRLoader"),", make sure that ",(0,o.kt)("inlineCode",{parentName:"p"},"BrowserTransferStateModule")," is imported, because ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesSSRLoader")," depends on ",(0,o.kt)("inlineCode",{parentName:"p"},"TransferState"),"."),(0,o.kt)("p",null,"There can be many different environment variables present on the server where your Angular Universal application is running. ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesSSRLoader")," has to be configured with information about which variables should be read from ",(0,o.kt)("inlineCode",{parentName:"p"},"process.env"),". Be careful not to expose any secrets to the browser (e.g. various tokens/keys that are present in ",(0,o.kt)("inlineCode",{parentName:"p"},"process.env"),"). This can be done as shown in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@NgModule({\n    imports: [\n        BrowserModule.withServerTransition({ appId: 'serverApp' }),\n        BrowserTransferStateModule,\n\n        EnvironmentVariablesModule,\n        EnvironmentVariablesSSRLoaderModule.withConfig({\n            variablesToLoad: [EnvironmentVariable.FOO, EnvironmentVariable.BAR],\n        }),\n    ],\n})\nexport class AppModule {}\n")),(0,o.kt)("h3",{id:"23-implementing-and-providing-a-custom-loader"},"2.3. Implementing and providing a custom loader"),(0,o.kt)("p",null,"Implement an injectable class that implements ",(0,o.kt)("inlineCode",{parentName:"p"},"IEnvironmentVariablesLoader"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Injectable()\nexport class MyEnvironmentVariablesLoader<TVariable extends string> implements IEnvironmentVariablesLoader<TVariable> {\n    public load(): EnvironmentVariablesRecord<TVariable> | Observable<EnvironmentVariablesRecord<TVariable>> {\n        ...\n    }\n}\n")),(0,o.kt)("p",null,"Provide your custom loader:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@NgModule({\n    imports: [EnvironmentVariablesModule],\n    providers: [\n        {\n            provide: ENVIRONMENT_VARIABLES_LOADER,\n            useClass: MyEnvironmentVariablesLoader,\n        },\n    ],\n})\nexport class AppModule {}\n")),(0,o.kt)("h3",{id:"24-setting-values-for-development-only"},"2.4. Setting values for development only"),(0,o.kt)("p",null,"During development, you might want to set environment variables so that, for example, ",(0,o.kt)("inlineCode",{parentName:"p"},"API_URL")," points to a localhost proxy. At the same time, don't want these development URLs to be part of the final application bundle. There are multiple ways to achieve this. One possible solution is to provide a custom loader only in development mode, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@NgModule({\n    imports: [\n        EnvironmentVariablesModule,\n        EnvironmentVariablesSSRLoaderModule.withConfig({\n            variablesToLoad: Object.values(EnvironmentVariable),\n        }),\n    ],\n    providers: [\n        // Development mode variables\n        ...(environment.production\n            ? []\n            : [\n                    {\n                        provide: ENVIRONMENT_VARIABLES_LOADER,\n                        useValue: {\n                            load: () => {\n                                return {\n                                    [EnvironmentVariable.API_URL]: 'http://localhost:4200/api',\n                                };\n                            },\n                        },\n                    },\n              ]),\n    ],\n})\nexport class AppModule {}\n")),(0,o.kt)("p",null,"Because we use ",(0,o.kt)("inlineCode",{parentName:"p"},"environment.production"),", custom loader will be tree-shaken at build-time and will not be present in the production application bundle - it will only be used during development. This keeps the production bundle clear of any development-related environment variables values. You can also consider adding an additional boolean to your environment files, e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"useDevelopmentEnvironmentVariablesValues"),". The value of this property will most probably be in-sync with ",(0,o.kt)("inlineCode",{parentName:"p"},"production")," property value but it does not have to be, especially if you have more than two environment files."),(0,o.kt)("p",null,"There is an opinion piece later on in this documentation page describing what we should or should not use environment files for. This is a good example of a use case where we can use environment files."),(0,o.kt)("h3",{id:"25-example-applications"},"2.5. Example applications"),(0,o.kt)("p",null,"Please check out the source code repository for two example applications."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/infinum/ngx-nuts-and-bolts/tree/main/apps/environment-variables-fetch-example"},(0,o.kt)("inlineCode",{parentName:"a"},"apps/environment-variables-fetch-example"))," demonstrates an example that uses ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesStaticLoader"),". In ",(0,o.kt)("inlineCode",{parentName:"p"},"main.ts")," (before the application is loaded), ",(0,o.kt)("inlineCode",{parentName:"p"},"./assets/env.json")," is fetched using ",(0,o.kt)("inlineCode",{parentName:"p"},"fetch")," and the application is bootstrapped with the loader provided in ",(0,o.kt)("inlineCode",{parentName:"p"},"main.ts")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"app.module.ts")," (as you would do usually). You can start this example with ",(0,o.kt)("inlineCode",{parentName:"p"},"npm run start:environment-variables-fetch-example"),"."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/infinum/ngx-nuts-and-bolts/tree/main/apps/environment-variables-ssr-example"},(0,o.kt)("inlineCode",{parentName:"a"},"apps/environment-variables-ssr-example"))," uses ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesSSRLoader"),". The application has to be started with environment variables exposed to the node process that is running the SSR app. You can start this example with ",(0,o.kt)("inlineCode",{parentName:"p"},"npm run start:environment-variables-ssr-example")),(0,o.kt)("h2",{id:"3-unit-testing"},"3. Unit testing"),(0,o.kt)("p",null,"For unit testing, you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesTestingModule"),", which is inspired by Transloco's ",(0,o.kt)("a",{parentName:"p",href:"https://ngneat.github.io/transloco/docs/unit-testing/"},(0,o.kt)("inlineCode",{parentName:"a"},"TranslocoTestingModule")),"."),(0,o.kt)("p",null,"By using ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesTestingModule"),"'s ",(0,o.kt)("inlineCode",{parentName:"p"},"withMockEnvironment")," method, you can create a testing module with mock values for environment variables:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="/src/testing/environment-variables-testing-module.ts"',title:'"/src/testing/environment-variables-testing-module.ts"'},"import { EnvironmentVariablesTestingModule } from '@infinumjs/ngx-nuts-and-bolts';\nimport { EnvironmentVariable } from 'src/app/enums/environment-variable.enum';\n\nexport const MyAppEnvironmentVariablesTestingModule = EnvironmentVariablesTestingModule.withMockEnvironment({\n    [EnvironmentVariable.FOO]: 'I am Foo (testing)',\n    [EnvironmentVariable.BAR]: 'I am Bar (testing)',\n});\n")),(0,o.kt)("p",null,"Then, you can importing this module in the ",(0,o.kt)("inlineCode",{parentName:"p"},"TestBed")," for a specific component/service/whatever:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="/src/app/components/foo/foo.component.spec.ts"',title:'"/src/app/components/foo/foo.component.spec.ts"'},"import { TestBed } from '@angular/core/testing';\nimport { EnvironmentVariable } from 'src/app/enums/environment-variable.enum';\nimport { MyAppEnvironmentVariablesTestingModule } from 'src/testing/my-app-environment-variables.testing.module';\n\ndescribe('foo component', () => {\n    beforeEach(() => {\n        TestBed.configureTestingModule({\n            imports: [MyAppEnvironmentVariablesTestingModule],\n        });\n    });\n});\n")),(0,o.kt)("p",null,"If you want to test how your application handles specific environment variable values other than the default ones from ",(0,o.kt)("inlineCode",{parentName:"p"},"MyAppEnvironmentVariablesTestingModule"),", you can create a new, more specific, testing module for that test suite and/or you can spy on ",(0,o.kt)("inlineCode",{parentName:"p"},"EnvironmentVariablesService"),"'s ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," method and return the desired value that is relevant for that specific test."),(0,o.kt)("p",null,"You can see some examples in the repository ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/infinum/ngx-nuts-and-bolts/blob/7e2c0d6bcf33dfc3a9a5e7fb5bd9f3849960e4fc/libs/environment-variables-example-app-base/src/lib/pipes/environment-variable-value/environment-variable-value.pipe.spec.ts"},"here")," and ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/infinum/ngx-nuts-and-bolts/blob/7e2c0d6bcf33dfc3a9a5e7fb5bd9f3849960e4fc/libs/environment-variables-example-app-base/src/lib/testing/my-app-environment-variables.testing.module.ts"},"here"),"."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Note:")," Apply better naming than ",(0,o.kt)("inlineCode",{parentName:"p"},"MyApp")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"MyAppEnvironmentVariablesTestingModule"),"."),(0,o.kt)("h2",{id:"4-opinion-piece---what-about-angulars-environment-files"},"4. Opinion piece - what about Angular's ",(0,o.kt)("inlineCode",{parentName:"h2"},"environment")," files?"),(0,o.kt)("p",null,"While Angular provides environment files out-of-the-box (one for development and one for production), but they are not the best solution to this problem for multiple reasons:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Any changes to these files require application re-build and re-deployment"),(0,o.kt)("li",{parentName:"ul"},"Adding a new requirement requires code changes"),(0,o.kt)("li",{parentName:"ul"},"One build per environment",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"At best, this is sub-optimal"),(0,o.kt)("li",{parentName:"ul"},"At worst, it can lead to situations where you think that the builds for different environments were made from the same commit, but something might have been pushed in the meantime and the builds will be different"))),(0,o.kt)("li",{parentName:"ul"},"One file is required for each environment"),(0,o.kt)("li",{parentName:"ul"},"A configuration entry has to be added to ",(0,o.kt)("inlineCode",{parentName:"li"},"angular.json")," for each file"),(0,o.kt)("li",{parentName:"ul"},"Conceptually, the frontend repository should not care about any URLs or other values that are related to the deployment process - they should be stored in the deployment pipeline",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The only thing that is OK to keep in the frontend repository are URLs for development proxies"))),(0,o.kt)("li",{parentName:"ul"},"Some projects have a CI/CD setup such that each branch gets deployed to some unique environment so that the application is available online as part of pull request and design review processes. This is basically impossible to do with environment files without some hacky file copying and/or search-and-replace of some placeholder values")),(0,o.kt)("p",null,"Although these out-of-the-box files are named ",(0,o.kt)("inlineCode",{parentName:"p"},"environment.ts")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"environment.prod.ts"),", Angular CLI has refers to these files in the ",(0,o.kt)("inlineCode",{parentName:"p"},"configurations")," segment of ",(0,o.kt)("inlineCode",{parentName:"p"},"angular.json"),". Basically, there is a 1-to-1 mapping between build configurations in ",(0,o.kt)("inlineCode",{parentName:"p"},"angular.json")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"environment.ts")," files. ",(0,o.kt)("inlineCode",{parentName:"p"},"configurations")," would probably be a more suitable name because these files are not the best fit for defining environment-specific values likeAPI URL, for all the reasons mentioned before. The main purpose for these files should be to define differences in build configurations - think of them as pragmas. Out-of-the-box they are used to determine whether Angular should run in production or development mode. Similar to the out-of-the-box ",(0,o.kt)("inlineCode",{parentName:"p"},"production")," boolean property, you might have some custom properties that are used, for example, to determine if something should be logged or not in different build configurations."),(0,o.kt)("p",null,"Even though one of the configurations is called ",(0,o.kt)("inlineCode",{parentName:"p"},"production")," and the other ",(0,o.kt)("inlineCode",{parentName:"p"},"development"),", these are usually the only two configurations you actually need. In environments where it is important to provide a optimized build to the end-user, use ",(0,o.kt)("inlineCode",{parentName:"p"},"production")," configuration. In environments where it is important that you can easily debug the deployed code, use ",(0,o.kt)("inlineCode",{parentName:"p"},"development")," configuration. Even if you have many different environments, you are probably still ok with using one of these two configurations in each of the environments (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"production")," configuration for production and pre-production environments and ",(0,o.kt)("inlineCode",{parentName:"p"},"development")," for development environments). You might want to add one additional middle-ground configuration that has all the optimizations enabled, but also includes sourcemaps that can be used to help with debugging. Basically ",(0,o.kt)("inlineCode",{parentName:"p"},"production")," configuration + sourcemaps on top."),(0,o.kt)("p",null,"We can only hope that one day Angular CLI completely drops ",(0,o.kt)("inlineCode",{parentName:"p"},"environment")," from naming and starts calling these files ",(0,o.kt)("inlineCode",{parentName:"p"},"configuration")," files (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"configuration.dev.ts"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"configuration.prod.ts"),"). This would better convey use cases where these files are a good fit. Environment variables should be kept out of these files in most applications. If you think these files will work for your use case, feel free to use them. However, we believe that they are not a good fit for anything other than some really small-scale and/or demo projects."))}u.isMDXComponent=!0}}]);